### 快速排序与二叉排序树

快速排序的基准值 类似二叉排序树的根结点

时间复杂度 与 查找长度 最好相同、最坏相同



二叉排序树中序遍历后是有序的

所有结点的前序都是它左子树的最右结点（出度为1或0）

删除出度为2的结点时，找到该结点左子树中最右结点并与之交换，便转化为删除出度为1或0节点的问题





## 平衡二叉排序树

为了防止二叉排序树退化成链表

旋转

* AVL
* SBT(SIze Balanced Tree)
* 红黑树
* Treap
* 替罪羊树





## AVL

H是树高

BST 结点数量

`H <= H <= 2的H次幂 - 1`

AVL 结点数量

`low(H - 2) + low(H - 1) + 1 <= H <= 2的H次幂 - 1` 

最少结点数量类似斐波那契



### 自平衡条件

任何结点的两个子树的高度最大差别为1



### 旋转操作

#### 左旋

当前结点右孩子变成根结点 当前结点变成其右孩子的左孩子 其右孩子的左孩子变成当前结点的右孩子

#### 右旋

当前结点左孩子变成根结点 当前结点变成其左孩子的右孩子 其左孩子的右孩子变成当前结点的左孩子





### AVL树失衡的解决办法

* LL  大右旋

* LR 小左旋后变成LL型，再大右旋

* RL 小右旋后变成RR型，再大左旋

* RR 大左旋



## SBT

### 自平衡条件

`size[t]`表示t节点所在子树的结点个数，对于每个结点t，同时满足：

1. `size[right[t]] >= max(size[left[left[t]]], size[right[left[t]]])`
2. `size[left[t]] >= max(size[left[right[t]]], size[right[right[t]]])`

**每个结点所在子树的结点个数不小于其兄弟的两个孩子所在子树的结点个数**



### 旋转操作

同AVL树一样



### SBT树失衡的解决办法

* LL型（size[left[left[t]]]  > size[right[t]]）：首先对子树t执行右旋操作，旋转以后对t的右子树进行调整，之后再对子树t进行调整
* LR型（size[right[left[t]]]  > size[right[t]]）：首先对t的左子树执行左旋操作，再对t进行右旋转操作，之后再分别调整结点t的左右子树，最终对结点t进行调整
* RR型（size[right[right[t]]]  > size[left[t]]）：首先对子树t执行左旋操作，旋转以后对t的左子树进行调整，之后再对子树t进行调整
* RL型（size[left[right[t]]] > size[left[t]]）首先对t的右子树执行右旋操作，再对t进行左旋转操作，之后再分别调整结点t的左右子树，最终对结点t进行调整

**SBT只有在插入时才可能触发调整，不需要在删除结点以后进行调整**





## 红黑树

### 五个条件

1. 每个节点非黑即红
2. 根节点是黑色
3. 叶子节点（NIL）的黑色
4. 如果一个结点是红色，则它的两个子节点都是黑色的
5. **从根节点出发到所有叶节点路径上，黑色节点数量相同**



### 调整策略

1. 插入调整站在**祖父节点**看
2. 删除调整站在**父节点**看
3. 插入和删除的情况处理一共五种

