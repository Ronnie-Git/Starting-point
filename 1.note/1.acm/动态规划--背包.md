[TOC]



## 01背包

**每个物品最多只能放一次**

求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要**恰好装满背包**时的最优解，有的题目则并**没有要求必须把背包装满**。一种区别这两种问法的实现方法是在**初始化的时候有所不同**。



### 模板题目 (不要求背包是否装满)

**将`dp数组`初始化为零即可**

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。



#### 基本思路

这是最基础的背包问题，特点是：**每种物品仅有一件，可以选择放或不放。**

用子问题定义状态：即`f[i][v]`表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。



#### 状态转移方程

**`f[i][v] = max(f[i-1][v], f[i-1][v-c[i]] + w[i]);`**

基本上所有跟背包相关的问题的方程都是由它衍生出来的。



#### 思路解析

* “将前`i`件物品放入容量为`v`的背包中”这个子问题，若只考虑第`i`件物品的策略（放或不放），那么就可以转化为一个只牵扯前`i-1`件物品的问题。

* 如果不放第`i`件物品，那么问题就转化为“前`i-1`件物品放入容量为`v`的背包中”，价值为`f[i-1][v]`。
* 如果放第`i`件物品，那么问题就转化为“前`i-1`件物品放入剩下的容量为`v-c[i]`的背包中”，此时能获得的最大价值就是`f[i-1][v-c[i]]`再加上通过放入第`i`件物品获得的价值`w[i]` ，即`f[i-1][v-c[i]] + w[i]`。



#### 示例代码（后续会降到一维）

```c++
for (int i = 0; i < n; i++) {
    for (int v = V; v >= c[i]; v--) {
        f[i][v] = max(f[i-1][v], f[i-1][v-c[i]] + w[i]); // 代码实现 动态转移方程
    }
}
```

现在的`f[v-c[i]]`就相当于原来的`f[i-1][v-c[i]]`。如果将`v`的循环顺序从上面的**逆序改成顺序**的话，那么则成了`f[i][v]`由`f[i][v-c[i]]`推知，**与本题意不符**，但它却是另一个重要的背包问题**完全背包**最简捷的解决方案。



#### 优化空间复杂度

以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。

前面的示例程序写成`v=V..0`是为了在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。而这里既然已经抽象成看作黑箱的过程了，就可以加入优化。**费用为`cost`的物品不会影响状态`f[0..cost-1]`**，这是显然的。



#### 一维01背包代码（最常用的01背包模板）

```c++
for (int i = 0; i < n; i++) {
    for (int v = V; v >= c[i]; v--) {
        f[v] = max(f[v], f[v-c[i]] + w[i]); // 动态转移方程 一维实现
    }
}
```



### 例题  开心的金明

https://nanti.jisuanke.com/t/284

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

// 复习一下结构体的使用方式
typedef struct arr {
    int w, data;
} arr;

int main() {
    int n, m, dp[30005] = {0}; // 没有要求将背包恰好装满 初始化为零即可
    arr num[30005];
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> num[i].w >> num[i].data;
        num[i].data *= num[i].w; // 将价格和重要度的乘积作为价值
    }
    
    // 01背包模板
    for (int i = 0; i < m; i++) {
        for (int j = n; j >= num[i].w; j--) {
            dp[j] = max(dp[j], dp[j - num[i].w] + num[i].data);
        }
    }
    cout << dp[n] << endl;
    return 0;
}
```





### 背包恰好装满求最大价值

在初始化时除了**`f[0]`为`0`其它`f[1..V]`均设为`-∞`**，这样就可以保证最终得到的`f[N]`是一种恰好装满背包的最优解。

`dp[0] = 0 其他位置赋为负无穷（-0x3f3f3f3f-1）`



有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包，并且背包恰好被装满时可使价值总和最大。

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

#define INF 0x3f3f3f3f

int main() {
    int n, m;
    int c[105] = {0}, w[105] = {0}, dp[10005] = {0};
    dp[0] = 1;
    cin >> n >> m;
    for (int i = 1; i < 10005; i++) dp[i] = -INF - 1;
    for (int i = 0; i < n; i++) cin >> c[i] >> w[i];
    for (int i = 0; i < n; i++) {
        for (int j = m; j >= c[i]; j--) {
            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);
        }
    }
    cout << dp[m] << endl;
    return 0;
}
```





### 小结

01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，认真体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度，01背包的几种形式。

**最重要的就是思维模型（状态转移方程）的确立，思维模型确立的好很多背包问题都可以转化为01背包**



**为什么恰好装满和非必须装满的初始化状态不同？**

* 初始化的`dp数组`事实上就是在没有任何物品可以放入背包时的合法状态。
* 如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0，体积为0的物品（什么都不装）“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是`-∞`了。
* 如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。



## 完全背包

**每种物品可以放无限多次**

**无需装满和恰好装满同01背包的解决思想**



#### 状态转移方程

**`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}`**

* 01背包中因为要保证第`i`次循环中的状态`f[i][v]`是由状态`f[i-1][v-c[i]]`递推而来。这正是为了保证**每件物品只选一次**，保证在考虑“选入第i件物品”这件策略时，依据的是一个**没有选入第`i`件物品的子结果`f[i-1][v-c[i]]`**。所以01背包中要按照v=V..0的**逆序来循环**。

* 完全背包的特点恰是**每种物品可选无限件**，所以在考虑“加选一件第i种物品”这种策略时，却正**需要一个可能已选入第i种物品的子结果`f[i][v-c[i]]`**，所以就可以并且必须采用v=0..V的**顺序循环**。这就是这个简单的程序为何成立的道理。

**所以也可以这样建立状态转移方程**

**`f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}`**



#### 代码

```c++
for (int i = 0; i < n; i++) {
    for (int v = c[i]; v <= V; v++) { // 只需将01背包中的逆序循环改为正序循环即可
        f[v] = max(f[v], f[v-c[i]] + w[i]);
    }
}
```



### 例题  P1616 疯狂的采药

https://www.luogu.org/problemnew/show/P1616

```c++
#include<iostream>
#include <cmath>
#include <algorithm>
using namespace std;
int T, M, dp[100005], t[100005], w[100005];
int main() {
    cin >> T >> M;
    for (int i = 0; i < M; ++i) cin >> t[i] >> w[i];
    for (int i = 0; i < M; ++i) {
        for (int j = t[i]; j <= T; ++j) { // 因为无限次 无论dp[j-c[i]]选没选过c[i]都可以 
             dp[j] = max(dp[j], dp[j - t[i]] +  w[i]);
        }
    }
    cout << dp[T] << endl;
    return 0;
}
```



#### 小结

先说下 01 背包，有n 种不同的物品，每个物品有两个属性v 体积，w 价值，现在给一个容量为 m 的背包，问
最多可带走多少价值的物品。

```c++
for (int i = 0; i < n; i++) {
	for (int j = m; j >= v[i]; j--)
		dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
	}
}
```



如果物品不计件数，就是每个物品不只一件的话，稍微改下即可

```c++
for (int i = 0; i < n; i++) {
    for (int j = v[i]; j <= m; j++) {
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}
```

初始化分两种情况

1. 如果背包要求正好装满则初始化 **`dp[0] = 0, dp[1~w] = -INF;`**
2. 如果不需要正好装满 **`dp[0~v] = 0;`**





## 多重背包

每种物品有一个固定的次数上限

* 将一个物品通过二进制拆分变成多个物品，再通过01背包求解
* 单调队列优化



#### 状态转移方程

**`f[i][v]=max{f[i-1][v-k\*c[i]]+k*w[i]|0<=k<=n[i]}`**



### 二进制优化

多重背包问题要求很简单，就是每件物品给出确定的件数，求可得到的最大价值。
多重背包转换成 01 背包问题就是多了个初始化，把它的件数C 用分解成若干个件数的集合，这里面数字可以组合成任意小于等于C的件数，而且不会重复，之所以叫二进制分解，是因为这样分解可以用数字的二进制形式来解释

比如：

* 7的二进制 7 = 111 它可以分解成 001 010 100 这三个数可以组合成任意小于等于7 的数，而且每种组合都会得到不同的数
* 15 = 1111 可分解成 0001  0010  0100  1000 四个数字
* 如果13 = 1101 则分解为 0001 0010 0100 0110 前三个数字可以组合成7以内任意一个数，加上 0110 = 6 可以组合成任意一个大于6 小于13的数，虽然有重复但总是能把 13 以内所有的数都考虑到了

基于这种思想去把多件物品转换为，多种一件物品，就可用01 背包求解了。



```c++
int n;  //输入有多少种物品
int k;  //每种物品有多少件
int w;  //每种物品的价值
int s;  //每种物品的尺寸
int count = 0; //分解后可得到多少种物品
int value[MAX_N]; //用来保存分解后的物品价值
int size[MAX_N];  //用来保存分解后物品体积
cin >> n;   //先输入有多少种物品，接下来对每种物品进行分解
while (n--) {   //接下来输入n中这个物品
	cin >> k >> s >> w;  //输入每种物品的数目和价值
    for (int i = 1; i <= k; i <<= 1) { //<<左移 相当于乘二
        value[count] = i * w;
        size[count++] = i * s;
        k -= i;
    }
    if (k > 0) {
        value[count] = k * w;
        size[count++] = k * s;
    }
}
//现在用count 代替 n 就和01 背包问题完全一样了
```



### 单调队列优化

#### 代码

```c++
//“多重背包”通用模板
#define MAX_V 100005;
//v、n、w：当前所处理的这类物品的体积、个数、价值
//V：背包体积， MAX_V：背包的体积上限值
//f[i]：体积为i的背包装前几种物品，能达到的价值上限。
void pack(int *dp, int V, int v, int n, int w) {
    if (n == 0 || v == 0) return;
  	if (n == 1) {               //01背包
    	for (int i = V; i >= v; --i) {
      		dp[i] = max(dp[i], dp[i - v] + w);
        }
    	return;
  	}
  	if (n * v >= V - v + 1) {   //完全背包(n >= V / v)
    	for (int i = v; i <= V; ++i) {
      		dp[i] = max(dp[i], dp[i - v] + w);
        }
    	return;    
  	}
    
  	int va[MAX_V], vb[MAX_V];   //va/vb: 主/辅助队列
  	for (int j = 0; j < v; ++j) {     //多重背包
    	int pb = 0, pe = -1;     //pb/pe分别指向队列首/末元素
    	int qb = 0, qe = -1;     //qb/qe分别指向辅助队列首/末元素  
    	for (int k = j, i = 0; k <= V; k += v, ++i) {
      		if (pe == pb + n) {       //若队列大小达到指定值，第一个元素X出队。
        		if (va[pb] == vb[qb]) ++qb;   //若辅助队列第一个元素等于X，该元素也出队。 
        		++pb;
      		}
      		int tt = dp[k] - i * w;
      		va[++pe] = tt;                  //元素X进队
      			//删除辅助队列所有小于X的元素，qb到qe单调递减，也可以用二分法
      		while (qe >= qb && vb[qe] < tt) --qe;
      		vb[++qe] = tt;              //元素X也存放入辅助队列        
      		dp[k] = vb[qb] + i * w;      //辅助队列首元素恒为指定队列所有元素的最大值
    	}
  	}
    return ;
}
```



### 例题 HDU2191

**模板题，直接套模板即可，代码略**

分别使用三种方法解题：

1. 三层for，01背包
2. 二进制优化，01背包，直接套模板
3. 单调队列优化，01背包，直接套模板





## 混合三种背包问题

#### 问题

有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。



#### 思路分析

**复杂的问题只需分解成我们学过的问题解决即可**，将每种情况分开求解，需要用哪种背包求解，就选择哪种背包



#### 代码框架

```c++
if 01背包 {
    01背包（第二层循环是倒序）
} else if 完全背包 {
    完全背包（第二层循环是正序）
} else 多重背包 {
    二进制优化 或 单调队列优化
    01背包
}
```





## 二维费用的背包问题

#### 问题

对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这**两种代价**；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。



#### 思路分析

**对于两种不同的费用，只需再加一维即可**

设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]



#### 状态转移方程

**`f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}`**



#### 特殊情况

一共最多只能取M件物品。这事实上相当于每件物品多了一种**件数的费用**，每个物品的**件数费用均为1**，可以付出的最大件数费用为M。设`f[v][m]`表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，**最后在`f[0..V][0..M]`范围内寻找答案**。



#### 小结

有很多问题都是由原来的问题变化二而来，再加一维是解决问题的一种办法，再转化为三种基础的背包模型去解决（01背包、完全背包、多重背包）





## 分组的背包问题

#### 问题

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。



#### 思路分析

这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设`f[k][v]`表示前k组物品花费费用v能取得的最大价值



#### 状态转移方程

**`f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组}`**



#### 代码

```c++
// 也可以使用结构体
/*
struct arr {
    int size;
    int num[MAX_M];
} arr[MAX_N];
*/

vector<int>arr[MAX_N];

for (int i = 0; i < k; i++) {
    for (int j = V; j >= 0; j--) {
        for (int l = 0; l < arr[i].size(); l++) {
            int ind = arr[i][l];
            if (j >= c[ind]) dp[j] = max(f[j], f[j - c[ind]] + w[ind]);
        }
    }
}
```



#### 小结

分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题，由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。





## 有依赖的背包问题

#### 问题

这种背包问题的物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。



### 例题 金明的预算方案

https://nanti.jisuanke.com/t/11589

#### 思路分析

一个物品最多有两个附件，不买主件便不能买附件，即可以采用分组思想，可分为五种情况：

1. 不买主件也不买其附件
2. 只买主件
3. 买主件和附件A
4. 买主件和附件B
5. 买主件和附件A和附件B

最后再使用01背包求解即可。



#### 代码

```c++
#include <iostream>
#include <cstdio>

using namespace std;

// cnt记录该主件和附件共有几种组合
typedef struct data {
    int cnt;
    int c[4];
    int w[4];
} data;

int main() {
    data num[70];
    for (int i = 0; i < 70; i++) num[i].cnt = 0;
    int dp[32005] = {0};
    int n, m, a, b, c, ind = 0;
    cin >> n >> m;
    // 将主件和附件的几种组合情况分别储存
    for (int i = 0; i < m; i++) {
        cin >> a >> b >> c;
        if (c == 0) {
            num[i].cnt = 1;
            num[i].c[0] = a;
            num[i].w[0] = a * b;
            continue;
        }
        int temp = num[c-1].cnt;
        num[c-1].c[temp] = num[c-1].c[0] + a;
        num[c-1].w[temp] = num[c-1].w[0] + a * b;
        num[c-1].cnt++;
        temp++;
        if (temp == 3) { // temp等于3代表有一个主件两个配件，把最后一种情况存入分组
            num[c-1].c[temp] = num[c-1].c[1] + a;
            num[c-1].w[temp] = num[c-1].w[1] + a * b;
            num[c-1].cnt++;
        }
    }
    
    for (int i = 0; i < m; i++) {
        if (num[i].cnt == 0) continue;
        for (int l = n; l >= 0; l--) {
            for (int j = 0; j <= num[i].cnt - 1; j++) {
                if (l - num[i].c[j] < 0) continue;
                dp[l] = max(dp[l], dp[l - num[i].c[j]] + num[i].w[j]);
            }
        }
    }
    cout << dp[n] << endl;
    return 0;
}
```





### 一般有依赖背包问题

依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。

解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。

事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。





## 泛化物品

#### 概念

考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。



#### 定义

在背包容量为V的背包问题中，泛化物品是一个定义域为0..V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是h(v)。



#### 背包中的泛化物品

背包容量为v，一个费用为c价值为w的物品，那么把它看成泛化物品

**01背包 泛化物品：**

只有**`h(c)=w`**，其它函数值都为**0**的一个函数。

**完全背包 泛化物品**

仅当v被c整除时有**`h(v)=v/c*w`**，其它函数值均为**0**

**多重背包 泛化物品**

如果它是多重背包中重复次数最多为n的物品，那么它对应的泛化物品的函数有**`h(v)=v/c*w  (0<=v/c<=n)`**，其它情况函数值均为**0**。

**物品组（分组背包、有依赖的背包） 泛化物品**

一个物品组可以看作一个泛化物品h。对于一个0..V中的v，若物品组中不存在费用为v的的物品，则h(v)=0，否则h(v)为所有费用为v的物品的最大价值。有依赖背包中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。



#### 小结

泛化物品是将背包问题上升到一个思维（抽象）的层面，这里不过深的介绍，需要大量的刷题去理解体会



## 背包问题的问法变化

背包问法变化非常多，此处以求方案数为例

### 求方案数（01背包版）

#### 状态转移方程

**`f[i][v]=sum{f[i-1][v],f[i][v-c[i]]}`**



### 例题 P1164 小A点菜

https://www.luogu.org/problemnew/show/P1164



#### 思路分析

只需将`dp[0] = 1 其他位置为0`，之后按01背包处理

**自行思考为什么dp[0] = 1, 其他部分为0**



#### 代码

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

int main() {
    int n, m;
    int num[105] = {0}, dp[10005] = {0};
    dp[0] = 1; // 剩余的钱买完一道菜后刚好用完 所以剩余的这些钱只有一种买法
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> num[i];
    for (int i = 0; i < n; i++) {
        for (int j = m; j >= num[i]; j--) {
            dp[j] += dp[j - num[i]]; // 现在的花费（方法数） += 不点这个菜的时候的花费（方法数）
        }
    }
    cout << dp[m] << endl;
    return 0;
}
```





## 背包总结

背包的变型题非常多，换一种思维理解，如何才能将一个问题转化为背包问题。

比如说一些简单的变型：

* 求解最小价值、最少件数
* 求方案数
* 求次优解、第k解



最基础**01背包、完全背包、多重背包**一定要学好，也要掌握一些简单的处理方式（分组背包、二维背包等），才能应对不同的背包问题。