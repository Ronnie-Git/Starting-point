## 存储任意类型的链表

```c
#ifdef __compiler_offsetof
#define offsetof(TYPE, MEMBER) __compiler_offsetof(TYPE, MEMBER)
#else
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER) 
#endif

/*
* #define offsetof(TYOE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER) //返回成员的偏移量
*
* type类型 0值空地址 member 把某个字段的地址赋值给相应的指针类型 
* __mptr指向list位置地址  得到相关变量的首地址 
*
* #define container_of(ptr, type, member) 求出type类型的首地址
*/
#define container_of(ptr, type, member) ({\
	const typeof( ((type *)0)->member) *__mptr = (ptr);\
	(type *)( (char *)__mptr - offsetof(type, member) );})

#include <stdio.h>

struct head_list {
    struct head_lsit *next;
    struct head_lsit *prev;
};

struct test_struct {
    int num;
    char ch;
    float fl;
    struct head_list list;
};

struct test_struct2 {
    int dobule;
    struct head_list list;
};
//test_struct 与 test_struct2 可以在一个链表中

int main() {
    struct test_struct init_struct = {20, 'C', 59.12, NULL};
    struct test_struct *test_struct = container_of(&init_struct.list, struct test_struct, list);
    printf(" test_struct->num = %d\n test_struct->ch = %c\n test_struct->fl = %f\n", test_struct->num, test_struct->ch, test_struct->fl);
    return 0;
}
```



### 第二种写法

30行变为`struct head_list *list;`

但41行传参时仍为`struct test_struct *test_struct = container_of(&init_struct.list, struct test_struct, list);`，因为`init_struct.list`是成员`list`的值，`&init_struct.list`才是成员`list`的地址

```c
#ifdef __compiler_offsetof
#define offsetof(TYPE, MEMBER) __compiler_offsetof(TYPE, MEMBER)
#else
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER) 
#endif

/*
* #define offsetof(TYOE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER) //返回成员的偏移量
*
* type类型 0值空地址 member 把某个字段的地址赋值给相应的指针类型 
* __mptr指向list位置地址  得到相关变量的首地址 
*
* #define container_of(ptr, type, member) 求出type类型的首地址
*/
#define container_of(ptr, type, member) ({\
	const typeof( ((type *)0)->member) *__mptr = (ptr);\
	(type *)( (char *)__mptr - offsetof(type, member) );})

#include <stdio.h>

struct head_list {
    struct head_lsit *next;
    struct head_lsit *prev;
};

struct test_struct {
    int num;
    char ch;
    float fl;
    struct head_list *list;
};

struct test_struct2 {
    int dobule;
    struct head_list *list;
};
//test_struct 与 test_struct2 可以在一个链表中

int main() {
    struct test_struct init_struct = {20, 'C', 59.12, NULL};
    struct test_struct *test_struct = container_of(&init_struct.list, struct test_struct, list);
    printf(" test_struct->num = %d\n test_struct->ch = %c\n test_struct->fl = %f\n", test_struct->num, test_struct->ch, test_struct->fl);
    return 0;
}
```



