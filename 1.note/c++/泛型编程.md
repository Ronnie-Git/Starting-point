## 泛型编程

* 模板
* c++中交换2个变量值
* 类模板



## 类模板 模板函数

```c++
template <typename T>
void _swap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
    return ;
}

template <typename T>
void _sort(T *arr, int len) {
    for (int i = 1; i < len; i++) {
        for (int j = i; j > 0; j--) {
            if (arr[j] < arr[j - 1]) _swap(arr[j], arr[j - 1]);
        }
    }
    return ;
}

template <typename T>
void print(T *arr, int len) {
    for (int i = 0; i < len; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    return ;
}
```



意义：

* c++泛型编程应用方式之一
* 函数模板能够根据实参类型进行参数类型推导
* 函数模板支持显式指定参数类型
* 函数模板是c++中代码复用的一种方式



1. 自动推导实参参数类型

2. 显式指定实参参数类型



函数模板注意事项：

* 函数模板本身不支持隐式转换
* 在自动推导类型时 必须严格遵守类型匹配 而不会进行隐式类型转化
* 显式指定类型时 能够进行隐式类型转化



多个类型参数时：

* 返回值类型无法自行推导
* 可以从左到右给出部分实参类型



如果多个参数类型时，把返回值类型写在最前面



**重载时 先看自己有没有操作符（运算符） 没有看系统**



**编译调用函数顺序（正常情况下）：**

* 普通函数和重载函数
* 模板函数
* 变参函数

在函数名后加`<>` 只调用模板函数   eg:`add<>()`



类模板

* 当在类外实现成员函数
* 类模板声明和实现在同一个头文件中（要写在一个文件中）

```c++
template <typename T>
返回值 class_name<T>::add() {}
//    类明            函数名
```



类模板：

* 可以有多个类型参数
* 特化只是类模板分开实现
* 特化的类模板使用方式都一样，必须显示指定参数类型

有多个特化的模板，根据不同的参数类型去选择不同的特化

函数模板也支持特化，只支持完全特化



完全特化：完全显示指定类型参数

部分特化：用特定规则去约束类型参数



模板参数可以是数值类型参数

```c++
template <typename T, int N>
void func() {
 	T a[N];
}
```

注意的事项：

* 数值类型参数不能用变量、不能用浮点类型、类类型

















