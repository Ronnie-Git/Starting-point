大佬的博客

https://blog.csdn.net/stack_queue/article/details/53544109



## 01背包

**每个物品最多只能放一次**

求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要**恰好装满背包**时的最优解，有的题目则并**没有要求必须把背包装满**。一种区别这两种问法的实现方法是在**初始化的时候有所不同**。



### 1.模板题目 (不要求背包是否装满)

**将`dp数组`初始化为零即可**

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。



#### 基本思路

这是最基础的背包问题，特点是：**每种物品仅有一件，可以选择放或不放。**

用子问题定义状态：即`f[i][v]`表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：

```c++
f[i][v] = max(f[i-1][v], f[i-1][v-c[i]] + w[i]);
```

基本上所有跟背包相关的问题的方程都是由它衍生出来的。



#### 思路解析

* “将前`i`件物品放入容量为`v`的背包中”这个子问题，若只考虑第`i`件物品的策略（放或不放），那么就可以转化为一个只牵扯前`i-1`件物品的问题。

* 如果不放第`i`件物品，那么问题就转化为“前`i-1`件物品放入容量为`v`的背包中”，价值为`f[i-1][v]`。
* 如果放第`i`件物品，那么问题就转化为“前`i-1`件物品放入剩下的容量为`v-c[i]`的背包中”，此时能获得的最大价值就是`f[i-1][v-c[i]]`再加上通过放入第`i`件物品获得的价值`w[i]` ，即`f[i-1][v-c[i]] + w[i]`。



#### 示例代码（后续会降到一维）

```c++
for (int i = 0; i < n; i++) {
    for (int v = V; v >= c[i]; v--) {
        f[i][v] = max(f[i-1][v], f[i-1][v-c[i]] + w[i]); // 代码实现 动态转移方程
    }
}
```

现在的`f[v-c[i]]`就相当于原来的`f[i-1][v-c[i]]`。如果将`v`的循环顺序从上面的**逆序改成顺序**的话，那么则成了`f[i][v]`由`f[i][v-c[i]]`推知，**与本题意不符**，但它却是另一个重要的背包问题**完全背包**最简捷的解决方案。



#### 优化空间复杂度

以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。

前面的示例程序写成`v=V..0`是为了在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。而这里既然已经抽象成看作黑箱的过程了，就可以加入优化。**费用为`cost`的物品不会影响状态`f[0..cost-1]`**，这是显然的。



#### 一维01背包代码（最常用的01背包模板）

```c++
for (int i = 0; i < n; i++) {
    for (int v = V; v >= c[i]; v--) {
        f[v] = max(f[v], f[v-c[i]] + w[i]); // 动态转移方程 一维实现
    }
}
```



#### 例题一  开心的金明

https://nanti.jisuanke.com/t/284

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

// 复习一下结构体的使用方式
typedef struct arr {
    int w, data;
} arr;

int main() {
    int n, m, dp[30005] = {0}; // 没有要求将背包恰好装满 初始化为零即可
    arr num[30005];
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> num[i].w >> num[i].data;
        num[i].data *= num[i].w; // 将价格和重要度的乘积作为价值
    }
    
    // 01背包模板
    for (int i = 0; i < m; i++) {
        for (int j = n; j >= num[i].w; j--) {
            dp[j] = max(dp[j], dp[j - num[i].w] + num[i].data);
        }
    }
    cout << dp[n] << endl;
    return 0;
}
```





### 2.背包恰好装满求最大价值

在初始化时除了**`f[0]`为`0`其它`f[1..V]`均设为`-∞`**，这样就可以保证最终得到的`f[N]`是一种恰好装满背包的最优解。

`dp[0] = 0 其他位置赋为负无穷（-0x3f3f3f3f-1）`



有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包，并且背包恰好被装满时可使价值总和最大。

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

#define INF 0x3f3f3f3f

int main() {
    int n, m;
    int c[105] = {0}, w[105] = {0}, dp[10005] = {0};
    dp[0] = 1;
    cin >> n >> m;
    for (int i = 1; i < 10005; i++) dp[i] = -INF - 1;
    for (int i = 0; i < n; i++) cin >> c[i] >> w[i];
    for (int i = 0; i < n; i++) {
        for (int j = m; j >= c[i]; j--) {
            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);
        }
    }
    cout << dp[m] << endl;
    return 0;
}
```





### 3.求方法数（其中一部分也属于01背包）

`dp[0] = 1 其他位置为0`



#### 例题二   P1164 小A点菜

https://www.luogu.org/problemnew/show/P1164

**自行思考为什么dp[0] = 1, 其他部分为0**

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

int main() {
    int n, m;
    int num[105] = {0}, dp[10005] = {0};
    dp[0] = 1; // 剩余的钱买完一道菜后刚好用完 所以剩余的这些钱只有一种买法
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> num[i];
    for (int i = 0; i < n; i++) {
        for (int j = m; j >= num[i]; j--) {
            dp[j] += dp[j - num[i]]; // 现在的花费（方法数） += 不点这个菜的时候的花费（方法数）
        }
    }
    cout << dp[m] << endl;
    return 0;
}
```



### 01背包总结

01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，认真体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度，01背包的几种形式。

**最重要的就是思维模型（状态转移方程）的确立，思维模型确立的好很多背包问题都可以转化为01背包**



**为什么恰好装满和非必须装满的初始化状态不同？**

* 初始化的`dp数组`事实上就是在没有任何物品可以放入背包时的合法状态。
* 如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0，体积为0的物品（什么都不装）“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是`-∞`了。
* 如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。



## 完全背包

**每种物品可以放无限多次**

**无需装满和恰好装满同01背包的解决思想**



状态转移方程

**`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}`**



* 01背包中因为要保证第`i`次循环中的状态`f[i][v]`是由状态`f[i-1][v-c[i]]`递推而来。这正是为了保证**每件物品只选一次**，保证在考虑“选入第i件物品”这件策略时，依据的是一个**没有选入第`i`件物品的子结果`f[i-1][v-c[i]]`**。所以01背包中要按照v=V..0的**逆序来循环**。

* 完全背包的特点恰是**每种物品可选无限件**，所以在考虑“加选一件第i种物品”这种策略时，却正**需要一个可能已选入第i种物品的子结果`f[i][v-c[i]]`**，所以就可以并且必须采用v=0..V的**顺序循环**。这就是这个简单的程序为何成立的道理。



所以也可以这样建立状态转移方程

**`f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}`**



```c++
for (int i = 0; i < n; i++) {
    for (int v >= c[i]; v <= V; v++) { // 只需将01背包中的逆序循环改为正序循环即可
        f[v] = max(f[v], f[v-c[i]] + w[i]);
    }
}
```



#### 例题三  P1616 疯狂的采药

https://www.luogu.org/problemnew/show/P1616

```c++
#include<iostream>
#include <cmath>
#include <algorithm>
using namespace std;
int T, M, dp[100005], t[100005], w[100005];
int main() {
    cin >> T >> M;
    for (int i = 0; i < M; ++i) cin >> t[i] >> w[i];
    for (int i = 0; i < M; ++i) {
        for (int j = t[i]; j <= T; ++j) { // 因为无限次 无论dp[j-c[i]]选没选过c[i]都可以 
             dp[j] = max(dp[j], dp[j - t[i]] +  w[i]);
        }
    }
    cout << dp[T] << endl;
    return 0;
}
```



#### 完全背包小结

先说下 01 背包，有n 种不同的物品，每个物品有两个属性
v 体积，w 价值，现在给一个容量为 m 的背包，问
最多可带走多少价值的物品。

```c++
for (int i = 0; i < n; i++) {
	for (int j = m; j >= v[i]; j--)
		dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
	}
}
```



如果物品不计件数，就是每个物品不只一件的话，稍微改下即可

```c++
for (int i = 0; i < n; i++) {
    for (int j = v[i]; j <= m; j++) {
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}
```


初始化分两种情况
1、如果背包要求正好装满则初始化 **`dp[0] = 0, dp[1~w] = -INF;`**
2、如果不需要正好装满 **`dp[0~v] = 0;`**



## 多重背包

每种物品有一个固定的次数上限

* 将一个物品通过二进制拆分变成多个物品，再通过01背包求解
* 单调队列优化



状态转移方程

**`f[i][v]=max{f[i-1][v-k\*c[i]]+k*w[i]|0<=k<=n[i]}`**



### 二进制优化

多重背包问题要求很简单，就是每件物品给出确定的件数，求可得到的最大价值。
多重背包转换成 01 背包问题就是多了个初始化，把它的件数C 用分解成若干个件数的集合，这里面数字可以组合成任意小于等于C的件数，而且不会重复，之所以叫二进制分解，是因为这样分解可以用数字的二进制形式来解释

比如：7的二进制 7 = 111 它可以分解成 001 010 100 这三个数可以组合成任意小于等于7 的数，而且每种组合都会得到不同的数
15 = 1111 可分解成 0001  0010  0100  1000 四个数字
如果13 = 1101 则分解为 0001 0010 0100 0110 前三个数字可以组合成7以内任意一个数，加上 0110 = 6 可以组合成任意一个大于6 小于13的数，虽然有重复但总是能把 13 以内所有的数都考虑到了，基于这种思想去把多件物品转换为，多种一件物品，就可用01 背包求解了。



```c++
int n;  //输入有多少种物品
int c;  //每种物品有多少件
int v;  //每种物品的价值
int s;  //每种物品的尺寸
int count = 0; //分解后可得到多少种物品
int value[MAX]; //用来保存分解后的物品价值
int size[MAX];  //用来保存分解后物品体积
scanf("%d", &n);    //先输入有多少种物品，接下来对每种物品进行分解
while (n--) {   //接下来输入n中这个物品
	scanf("%d%d%d", &c, &s, &v);  //输入每种物品的数目和价值
    for (int k=1; k<=c; k<<=1) { //<<左移 相当于乘二
        value[count] = k*v;
        size[count++] = k*s;
        c -= k;
    }
    if (c > 0) {
        value[count] = c*v;
        size[count++] = c*s;
    }
}
//现在用count 代替 n 就和01 背包问题完全一样了
```



### 单调队列优化



## 混合三种背包问题

有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？

```c++
if 01背包 {
    倒序
} else if 完全背包 {
    正序
} else 多重背包 {
    二进制优化 或 单调队列优化
    01背包
}

```

**复杂的问题只需分解成我们学过的问题解决即可**



## 二维费用的背包问题

对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]