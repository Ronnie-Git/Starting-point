# [18-4班作业] 李可新

## 作业一  证明线性筛使用一个Prime数组，不影响程序的正确性

prime数组初始化为零

```c
if (!prime[i]) prime[++prime[0]] = i;
```

0既不是素数也不是合数，不影响之后的标记，prime[0]作为计数器， 统计素数的数量。

```c
for (int j = 1; j <= prime[0] && prime[j] * i <= MAN_N; j++) {
    prime[i * prime[j]] = 1; //prime数组 标记合数
    if (i % prime[j] == 0) break;
}
```

prime数组储存素数时，标记合数时从prime[2]开始，储存素数时从prime[1]开始，当程序执行时 prime数组执行完标记合数的空间可用来储存素数，之间互不影响。

##  作业二  自行完成欧拉第10题

```c
#include <stdio.h>
#include <inttypes.h>

#define MAN_N 2000000

int prime[MAN_N + 5] = {0};

int main() {
    int64_t ans = 0;
    for (int i = 2; i <= MAN_N; i++) {
        if (!prime[i]) {
            prime[++prime[0]] = i;
            ans += i; 
        }
        for (int j = 1; j <= prime[0] && prime[j] * i <= MAN_N; j++) {
            prime[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }    
    }
    printf("%" PRId64 "\n", ans);
}
```

# 作业三  查阅资料，自学[缓存命中率]的相关知识

## 缓存命中率

终端用户访问加速节点时，如果该节点有缓存住了要被访问的数据时叫做命中，如没有需回服务器取，就没有命中。因取数据的过程与用户访问是同步进行的，所以即使是重新获取数据，用户也不会感到有延迟，通常来讲，缓存命中率越高则表示使用缓存的收益越高，应用的性能越好（响应时间越短、吞吐量越高），抗并发性的能力越强。命中率 = 命中数 / （命中数 + 没有命中数）。

## 影响因素

#### 缓存的粒度和策略

通常情况下，缓存的粒度越小，命中率越高。缓存的更新/过期策略也直接影响缓存命中率。当数据发生变化时，直接更新缓存的值会比移除缓存（或让缓存过期）的命中率更高。

#### 缓存容量

缓存太小，造成频繁的LRU（内存管理的一种页面置换算法，对于在内存中但又不用的数据块(内存块)叫做LRU)，也会降低命中率，缓存的有效期太短也会造成缓存命中率下降。

## 提高缓存命中率

可通过缓存预加载、增加储存容量、调整缓存粒度、更新缓存等手段来提高命中率。

# 作业四  自行完成欧拉第17题

```c
#include<stdio.h>

int num1 = 3 + 3 + 5 + 4 + 4 + 3 + 5 + 5 + 4; // 1 ~ 9求和
int num2 = 3 + 6 + 6 + 8 + 8 + 7 + 7 + 9 + 8 + 8;// 10 ～ 19求和
int num3 = 6 + 6 + 5 + 5 + 5 + 7 + 6 + 6;// 20 ～ 90（十位）求和
int num[5] = {7, 11};// num[0] hundred单词数 num[1] one thousand单词数
int main() {
    int ans = 0;
    ans = (num1 * 9 + num2 + num3 * 10) * 10 + (num1 + num[0] * 9) * 100 + 3 * 99 * 9 + num[1];//（1 ～ 99求和）* 10 + （百位求和）* 100 + 总and单词数 + 1000单词数
    printf("%d\n", ans);
    return 0;
}
```



# 作业五  自行完成欧拉第16题（选做）

```c
#include<stdio.h>

int ans[350] = {4, 4, 2, 0, 1};//倒序

int main() {
    int sum = 0;
    for (int i = 1; i < 100; ++i) {
        for (int j = 1; j <= ans[0]; ++j) {
            ans[j] *= 1024;//按位乘1024
        }
        for (int j = 1; j <= ans[0]; j++) {
            if (ans[j] < 10) continue;
            ans[j + 1] += ans[j] / 10;
            ans[j] %= 10;
            ans[0] += (j == ans[0]);//记位数
        }
    }
    for (int i = 1; i <= ans[0]; i++) {
        sum += ans[i];//位数求和
    }
    printf("%d\n", sum);
    return 0;
}
```









