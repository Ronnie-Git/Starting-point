# [18-4班作业] 李可新

## 作业一 自行完成欧拉33题

```c
#include <stdio.h>
#include <string.h>

int num[10][2] = {0};//储存满足条件的分子分母
int m[5][2] = {0};//计算可能满足条件的分子分母可能值
int k = 0;//计数器

int gcd (int a, int b) {//计算最大公因数
    return (b ? gcd(b, a % b) : a);
}

int solve (int i, int j) {
	for (int l = 1; l < 10; l++) {
		m[0][0] = i * 10 + l, m[0][1] = j * 10 + l;
        m[1][0] = i * 10 + l, m[1][1] = l * 10 + j;
        m[2][0] = l * 10 + i, m[2][1] = j * 10 + l;
        m[3][0] = l * 10 + i, m[3][1] = l * 10 + j;
        for (int p = 0; p < 4; p++) {
        	if (m[p][0] >= m[p][1]) continue;//分子大于分母 跳过
        	if ((m[p][0] / gcd(m[p][1], m[p][0]) == i / gcd(j, i)) && (m[p][1] / gcd(m[p][1], m[p][0]) == j / gcd(j, i))) {
                        k++;
                        num[k][0] = m[p][0];
                        num[k][1] = m[p][1];
        	}
      	}
	}
    return 0;
}

int main() {
    int k = 0;
    for (int i = 1; i < 9; i++) {
        for (int j = i + 1; j < 10; j++) {
            solve(i, j);// i 分子 j 分母
        }
    }
    int x = 1, y = 1, ans = 0;
    for (int i = 1; i < 5; ++i) {
        x *= num[i][0];
        y *= num[i][1];
        printf("%d %d\n", num[i][0], num[i][1]);
    }
    ans = y / gcd(y, x);
    printf("%d\n", ans);
    return 0;
}
```





## 作业二 自行完成欧拉35题

```c
#include <stdio.h>
#include <math.h>

#define MAX_N 1000000

int is_prime[MAX_N + 5] = {0};//标记素数
int prime[MAX_N + 5] = {0};//储存素数

void init() {//线性筛
    for (int i = 2; i <= MAX_N; i++) {
        if (!is_prime[i]) prime[++prime[0]] = i;
        for (int j = 1; j <= prime[0] && prime[j] * i <= MAX_N; j++) {
            is_prime[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }
    }
}

int main() {
    init();
    int flag = 0, k = 0;//k 计数器 flag 标记是否是循环素数
    for (int i = 1; i <= prime[0]; i++) {
        int n = floor(log10(prime[i])), x = prime[i];// n 位数-1
        do {
            if (prime[i] < 10) break;//小于10的都是
            x = x / (int)pow(10, n) + x % (int)pow(10, n) * 10;
            if (is_prime[x]) {// 判断是否是循环素数
                flag = 1;
                break;
            }
        } while (x != prime[i]);
        if (!flag) k++;
        flag = 0;
    }
    printf("%d\n", k);
    return 0;
}
```



## 作业三 自行完成欧拉37题

```c
#include <stdio.h>
#include <math.h>

#define MAX_N 1000000

int is_prime[MAX_N + 5] = {0};//标记素数
int prime[MAX_N + 5] = {0};//储存素数

void init() {//线性筛
    for (int i = 2; i <= MAX_N; i++) {
        if (!is_prime[i]) prime[++prime[0]] = i;
        for (int j = 1; j <= prime[0] && prime[j] * i <= MAX_N; j++) {
            is_prime[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }
    }
}

int left(int x) {//左删
    while (x) {
        if (is_prime[x]) return 0;
        x %= (int)pow(10, floor(log10(x)));
    }
    return 1;
}

int right(int x) {//右删
    while (x) {
        if (is_prime[x]) return 0;
        x /= 10;
    }
    return 1;	
}

int main() {
    init();
    is_prime[0] = 1, is_prime[1] = 1;
    int ans = 0;
    for (int i = 1; i <= prime[0]; i++) {
        if (prime[i] < 10) continue;
        if (left(prime[i]) && right(prime[i])) ans += prime[i];
    }
    printf("%d\n", ans);
    return 0;
}
```



## 作业四 自行完成欧拉43题

```c
#include <iostream>
#include <algorithm>
#include <cstdio>

using namespace std;

int prime[10] = {2, 3, 5, 7, 11, 13, 17};

long long int check(int *num) {
    long long int temp = 0, ans = 0;
    if (!num[0]) return 0;
    for (int i = 0; i < 7; i++) {
        temp = num[i + 1] * 100 + num[i + 2] * 10  + num[i + 3];//求相邻的三位数
        if (temp % prime[i] != 0) return 0;    
    }
    for (int i = 0; i < 10; i++) ans = ans * 10 + num[i];
    return ans;
}

int main() {
    int num[10] = {0};
    long long int sum = 0, n;
    for (int i = 0; i < 10; i++) num[i] = i;
    do {
        sum += check(num);
    } while (next_permutation(num, num + 10));//全排列函数
    printf("%lld\n", sum);
    return 0;
}
```



## 作业五 完成欧拉44题中的二分查找练习题

```c
#include <stdio.h>
#include <inttypes.h>

int64_t check(int64_t x) {//判断是否是3次方数 是返回1 否返回0
    int64_t left = -100000, right = 100000, mid;
    while (left <= right) {
        mid = (left + right) >> 1;
        if (mid * mid * mid == x) return 1;
        if (mid * mid * mid > x) right = mid - 1;
        else left = mid + 1;
    }
    return 0;
}

int main() {
    int64_t n;
    scanf("%"PRId64"", &n);
    printf("%s\n", check(n) ? "YES" : "NO");
    return 0;
}
```

