# SHELL

`/dev/null` ubuntu垃圾桶

`/dev/zero` ubuntu垃圾桶



`#!/bin/bash` shell文件开头

代码后   `一个空格#` 后写注释

`bash 文件`  对.`sh`文件作用同于`./`

`chmod` 改变权限  `a+x `  a所有人  给a加上x权限

`./可执行文件`  执行文件

`/`  目录文件拼接

` `` `   命令替换符

`if [[ 0 ]]`执行

`if [[ 1 ]]` 不执行



####  `read [-选项] [变量...]`

`-a arry`  把输入赋值到数组arry中，从索引号零开始

`-d delimiter`  用字符串delimiter中的第一个字符指示输入结束，而不是一个换行符

`-e`  使用Readine来处理。这使得与命令相同的方式编辑输入

`-n num`  读取num个输入字符，而不是整行

`-p prompt`  为输入显示提示信息，使用字符串prompt

`-r`  Raw mode. 不把`\`解释为转义字符

`-s`  Silent mode.

`-t seconds`  超时

`-u fd`  使用文件描述符fd中的输入，而不是标准输入



#### echo string

`echo -e "\n"`  开启转义 (会将\n转化为换行)

`echo “”`  （中文`“”` 会输出`“”`）

`echo "\"hello\""`  会在输出`"hello"`



#### `printf [格式化字符串] [arguments...]`  

`printf "hello $s\n" "hai zei"`

输出：hello hai zei



`$ `  取值  `$[较长的内容]`  取值

`echo $`  输出值

`$0 `  获取当前执行shell脚本的文件名，包括路径

`$n`  获取当前执行脚本的第n个参数，n=1...9，如果n大于9，则需要将n使用用大括号扩起来

`$*`  获取当前shell的所有参数，将所有命令行参数视为单个字符串，相当于`$1$2$3`

`$#`  得到执行当前脚本的参数个数

`$@`  获取这个程序所有参数，并保留参数 之间的任何空白，相当于`$1`  `$2`  `$3`，这是将参数传给其他程序的最好办法

`$? `  判断上一指令是否成功执行，0为成功，非零为不成功

`$$`  取当前进程的pwd

`$!`  上一指令的pwd



## 数组

可以这样定义数组`a=(1 2 3)`  或 `declare -a a`  或 `a[下标]=数值`



`${}`

`${arry[*]}`  输出数组内容

`${arry[@]}`  输出数组内容

`${#arry[@]}` 个数

`${!arry[@]}` 下标

`arry+=(a b c)` 数组追加

`sort` 数组排序

`unset` 删除数组与元素
